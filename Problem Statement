Distributed Key-Value Store Challenge
Your Task
In this challenge, you‚Äôll need to implement a distributed in-memory key-value store. The store should allow basic operations like Get, Set and Delete, and it should replicate data across multiple nodes.

Make sure to thoroughly review the requirements before starting and rely on your best judgement during implementation if anything is unspecified. We've intentionally kept this document concise to encourage your creative freedom and interpretation. This approach allows you to demonstrate your problem-solving abilities and innovative thinking.

What we're looking for
How you approach designing and implementing a service.
How you structure code to ensure it's well tested, easy to extend, easy to modify, easy to understand for others and that it complies with best practices for Go.
Documentation on how to build and run the project, specifically how to start multiple nodes and how to interact with the API. This information should be contained within the README.md file.
We don't expect you to write all the code required to solve this challenge, you're more than welcome to bring in other libraries to help you out.
Write notes! We'd love to have a glimpse into your thought process while tackling this challenge, tradeoffs you made in design choices, and thoughts that you have around how to improve upon the solution. Use the NOTES.md file for this.
Please remember to frequently pull your code into CodeSignal if you‚Äôre working outside of the platform. This helps us monitor your progress and understand your development process.
Some boilerplate code has been provided to speed up development. Feel free to edit or remove it as necessary to fit your specific use case.
‚è≥ The solution should be delivered at most in 7 days after you access the CodeSignal link provided.

What not to do
Don't prioritize writing perfect code or covering every logical path with tests over completing the task.
Requirements
Expose the Set, Get and Delete operations via an HTTP API:
GET /key/:key
If the key exists, return the key-value pair, for example {"key":"value"}.
If the key does not exist, return a not found message, for example {"message":"key not found"}.
POST /key
Should accept a payload like {"key":"value"} and return a message indicating if the operation was successful.
If the key does not exist, create the key-value pair and return a success message, for example {"message":"key created successfully"}.
If the key already exists, return a conflict message, for example {"message":"key already exists"}.
DELETE /key/:key
If the key exists, delete the key and return a success message, for example {"message":"key deleted successfully"}.
If the key does not exist, return a not found message, for example {"message":"key not found"}.
Keys should be unique.
Limit the length of keys to avoid excessively long strings that could impact performance.
Limit the size of values to avoid memory issues.
Implement detailed error messages and appropriate HTTP status codes for different failure scenarios.
Implement thread-safe operations to handle concurrent access to the key-value store.
Ensure the key-value store can handle a high number of requests per second.
Write a simple Go benchmark for the Set and Get operations, and describe what you would do to improve the benchmark results inside the NOTES.md file.
Expose a way for the nodes to be able to join the cluster and know about each other.
Ensure that data is replicated across multiple nodes with consensus. Use a 3rd party consensus library to assist with this.
Raft is a common algorithm that fits this use case. Feel free to use it in your solution or not, as long as the requirements presented are met.
One potential SDK that could be used is hashicorp/raft.
Ensure that the system can continue to operate correctly in the presence of node failures.
Create potential generated assets within the ./assets directory. Anything created within this directory will be ignored from the final submission.
Assumptions
The service runs in our internal network, with no exposure to the internet, and without any need to identify or authenticate the caller.
There are no hidden tests or code that will automatically score your exercise. It will be manually reviewed and graded by our team's engineers, with expectations being adjusted based to your seniority.
üçÄ Good luck! We're looking forward to reviewing your solution!

[execution time limit] 30 seconds

[memory limit] 1 GB